import argparse
import asyncio
import json
import os
import sys
import textwrap
from importlib import import_module
from typing import Any, Dict

from hft_platform.config.loader import (
    detect_live_credentials,
    load_settings,
    summarize_settings,
)
from hft_platform.utils.logging import configure_logging
from structlog import get_logger

logger = get_logger("cli")


def _safe_write(path: str, content: str):
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w") as f:
        f.write(content)


def cmd_run(args: argparse.Namespace):
    mode = args.mode or args.mode_flag or _resolve_default_mode()
    cli_overrides: Dict[str, Any] = {
        "mode": mode,
        "symbols": args.symbols or None,
    }
    if args.strategy:
        cli_overrides["strategy"] = {
            "id": args.strategy,
            "module": args.strategy_module or "hft_platform.strategies.simple_mm",
            "class": args.strategy_class or "SimpleMarketMaker",
            "params": {},
        }
    settings, defaults = load_settings({k: v for k, v in cli_overrides.items() if v})

    downgraded = None
    if settings.get("mode") == "live" and not detect_live_credentials():
        downgraded = "sim"
        settings["mode"] = "sim"
        logger.warning("No Shioaji credentials found, downgrading to sim mode")

    summary = summarize_settings(settings, downgraded_mode=downgraded)
    print(f"[hft run] {summary}")
    if downgraded:
        print("Hint: set SHIOAJI_API_KEY / SHIOAJI_SECRET_KEY to enable live.")

    if settings.get("mode") == "replay":
        print("Replay mode not yet wired; please use backtest runner directly.")
        return

    # Live/Sim share the same runtime pipeline; sim runs with Shioaji stub.
    from hft_platform.main import HFTSystem
    from prometheus_client import start_http_server

    start_http_server(settings.get("prometheus_port", 9090))
    print(f"Prometheus metrics started on :{settings.get('prometheus_port', 9090)}")

    system = HFTSystem(settings)
    try:
        asyncio.run(system.run())
    except KeyboardInterrupt:
        print("Interrupted, shutting down...")


def _resolve_default_mode() -> str:
    raw = str(os.getenv("HFT_MODE", "sim")).strip().lower()
    if raw == "real":
        return "live"
    if raw not in {"sim", "live", "replay"}:
        return "sim"
    return raw


def cmd_init(args: argparse.Namespace):
    """Question-lite init that drops a settings.py and a strategy skeleton."""
    strategy_id = args.strategy_id or "my_strategy"
    symbol = args.symbol or "2330"
    settings_tpl = (
        textwrap.dedent(
            f"""
        # Generated by hft init
        def get_settings():
            return {{
                "mode": "sim",
                "symbols": ["{symbol}"],
                "strategy": {{
                    "id": "{strategy_id}",
                    "module": "hft_platform.strategies.{strategy_id}",
                    "class": "Strategy",
                    "params": {{}},
                }},
                "paths": {{
                    "symbols": "config/symbols.yaml",
                    "strategy_limits": "config/base/strategy_limits.yaml",
                    "order_adapter": "config/base/order_adapter.yaml",
                }},
                "prometheus_port": 9090,
            }}
        """
        ).strip()
        + "\n"
    )

    strategy_tpl = (
        textwrap.dedent(
            f"""
        from structlog import get_logger
        from hft_platform.events import LOBStatsEvent
        from hft_platform.strategy.base import BaseStrategy

        logger = get_logger("{strategy_id}")


        class Strategy(BaseStrategy):
            default_params = {{"min_spread": 100, "qty": 1}}

            def __init__(self, strategy_id: str, **params):
                super().__init__(strategy_id)
                self.params = {{**self.default_params, **(params or {{}})}}
                self.symbols = {{"{symbol}"}}

            def on_stats(self, event: LOBStatsEvent):
                if event.symbol not in self.symbols:
                    return
                if event.spread <= self.params["min_spread"]:
                    return
                self.buy(event.symbol, event.best_bid, self.params["qty"])
                logger.info("placing order", price=event.best_bid, params=self.params)
        """
        ).strip()
        + "\n"
    )

    test_tpl = (
        textwrap.dedent(
            f"""
        import pytest
        from hft_platform.core.pricing import PriceCodec, SymbolMetadataPriceScaleProvider
        from hft_platform.strategies.{strategy_id} import Strategy
        from hft_platform.contracts.strategy import OrderIntent
        from hft_platform.events import LOBStatsEvent
        from hft_platform.feed_adapter.normalizer import SymbolMetadata
        from hft_platform.strategy.base import StrategyContext


        def _intent_factory(**kwargs):
            kwargs.setdefault("intent_id", 1)
            kwargs.setdefault("timestamp_ns", 0)
            return OrderIntent(**kwargs)

        def test_strategy_emits_intent():
            strat = Strategy(strategy_id="{strategy_id}")
            metadata = SymbolMetadata()
            price_codec = PriceCodec(SymbolMetadataPriceScaleProvider(metadata))
            ctx = StrategyContext(
                positions={{}},
                strategy_id="{strategy_id}",
                intent_factory=_intent_factory,
                price_scaler=price_codec.scale,
                lob_source=None,
            )
            event = LOBStatsEvent(
                symbol="{symbol}",
                ts=0,
                imbalance=0.0,
                best_bid=1000000,
                best_ask=1000200,
                bid_depth=10,
                ask_depth=10,
            )
            intents = strat.handle_event(ctx, event)
            assert intents, "strategy should emit intent on wide spread"
        """
        ).strip()
        + "\n"
    )

    _safe_write("config/settings.py", settings_tpl)
    _safe_write(f"src/hft_platform/strategies/{strategy_id}.py", strategy_tpl)
    _safe_write(f"tests/test_{strategy_id}.py", test_tpl)

    print("Initialized settings and strategy skeleton.")
    print(f"- config/settings.py\n- src/hft_platform/strategies/{strategy_id}.py\n- tests/test_{strategy_id}.py")
    print("Next steps: `hft run sim --strategy {strategy_id}` or `pytest -k test_{strategy_id}`")


def cmd_check(args: argparse.Namespace):
    settings, defaults = load_settings()
    missing = []
    if not settings.get("symbols"):
        missing.append("symbols")
    strat = settings.get("strategy", {})
    if not strat.get("id"):
        missing.append("strategy.id")
    if missing:
        print("Config errors:", ", ".join(missing))
        sys.exit(1)

    print("Configuration is valid.")
    if args.export:
        out = "config/exported_settings." + args.export
        if args.export == "yaml":
            try:
                import yaml

                payload = yaml.safe_dump(settings)
            except Exception:
                payload = json.dumps(settings, indent=2)
        else:
            payload = json.dumps(settings, indent=2)
        _safe_write(out, payload)
        print(f"Exported effective settings to {out}")


def cmd_wizard(args: argparse.Namespace):
    from hft_platform.config.wizard import run_wizard

    run_wizard()


def cmd_feed_status(args: argparse.Namespace):
    print("Feed status command is lightweight; ensure service is running.")
    # Try reading Prometheus metrics if reachable
    import urllib.request

    try:
        resp = urllib.request.urlopen(f"http://localhost:{args.port}/metrics", timeout=1.5)
        body = resp.read().decode("utf-8")
        has_feed = "feed_events_total" in body
        print(f"Metrics reachable on :{args.port}; feed metric present={has_feed}")
    except Exception as exc:
        print(f"Unable to reach metrics on :{args.port}: {exc}")


def cmd_diag(args: argparse.Namespace):
    # Minimal diag stub
    print("Diag:")
    print("- Check metrics at http://localhost:9090/metrics")
    print("- Common fixes: verify credentials, check network, ensure queues not full.")


def cmd_strat_test(args: argparse.Namespace):
    settings, _ = load_settings()
    module_name = args.module or settings.get("strategy", {}).get("module", "hft_platform.strategies.simple_mm")
    class_name = args.cls or settings.get("strategy", {}).get("class", "SimpleMarketMaker")
    strategy_id = args.strategy_id or settings.get("strategy", {}).get("id", "demo")
    symbol = args.symbol or (settings.get("symbols") or ["2330"])[0]
    try:
        mod = import_module(module_name)
        cls = getattr(mod, class_name)
    except Exception as exc:
        print(f"Failed to import strategy {module_name}.{class_name}: {exc}")
        sys.exit(1)

    strat = cls(strategy_id=strategy_id)

    from hft_platform.contracts.strategy import OrderIntent
    from hft_platform.core.pricing import PriceCodec, SymbolMetadataPriceScaleProvider
    from hft_platform.events import LOBStatsEvent
    from hft_platform.feed_adapter.normalizer import SymbolMetadata
    from hft_platform.strategy.base import StrategyContext

    def _intent_factory(**kwargs):
        kwargs.setdefault("intent_id", 1)
        kwargs.setdefault("timestamp_ns", 0)
        return OrderIntent(**kwargs)

    metadata = SymbolMetadata(settings.get("paths", {}).get("symbols"))
    price_codec = PriceCodec(SymbolMetadataPriceScaleProvider(metadata))

    ctx = StrategyContext(
        positions={},
        strategy_id=strategy_id,
        intent_factory=_intent_factory,
        price_scaler=price_codec.scale,
        lob_source=None,
    )

    event = LOBStatsEvent(
        symbol=symbol,
        ts=0,
        imbalance=0.0,
        best_bid=99,
        best_ask=101,
        bid_depth=10,
        ask_depth=10,
    )
    intents = strat.handle_event(ctx, event)
    print(f"Strategy emitted {len(intents)} intents.")
    for it in intents:
        print(f"- {it}")


def cmd_backtest(args: argparse.Namespace):
    if args.backtest_cmd is None:
        print("Please specify backtest subcommand (convert|run)")
        sys.exit(1)

    if args.backtest_cmd == "convert":
        try:
            from hft_platform.backtest.convert import convert_jsonl_to_npz

            convert_jsonl_to_npz(args.input, args.output, scale=args.scale)
            print(f"Converted to {args.output}")
        except Exception as exc:
            print(f"Convert failed: {exc}")
            sys.exit(1)
        return

    if args.backtest_cmd == "run":
        try:
            from hft_platform.backtest.adapter import StrategyHbtAdapter
            from hft_platform.backtest.runner import HftBacktestConfig, HftBacktestRunner
        except Exception as exc:
            print(f"Failed to import backtest modules: {exc}")
            sys.exit(1)

        # If strategy provided, use adapter; else simple buy-hold runner.
        if args.strategy_module:
            if len(args.data) > 1:
                print("Strategy bridge currently supports single-asset backtest; provide one data file.")
                sys.exit(1)
            adapter = StrategyHbtAdapter(
                data_path=args.data[0],
                strategy_module=args.strategy_module,
                strategy_class=args.strategy_class or "SimpleMarketMaker",
                strategy_id=args.strategy_id or "demo",
                symbol=args.symbol or "2330",
                tick_size=args.tick_size,
                lot_size=args.lot_size,
                price_scale=args.price_scale,
                timeout=args.timeout,
            )
            adapter.run()
            print("Strategy backtest completed.")
        else:
            cfg = HftBacktestConfig(
                data=args.data,
                symbols=args.symbols,
                tick_sizes=args.tick_sizes or [args.tick_size],
                lot_sizes=args.lot_sizes or [args.lot_size],
                latency_entry=args.latency_entry,
                latency_resp=args.latency_resp,
                fee_maker=args.fee_maker,
                fee_taker=args.fee_taker,
                partial_fill=not args.no_partial_fill,
                record_out=args.record_out,
                report=args.report,
            )
            runner = HftBacktestRunner(cfg)
            runner.run()
            print("Backtest completed.")


def cmd_resolve_symbols(args: argparse.Namespace):
    """Resolve TSE/OTC exchanges for a list of symbols or from config."""
    import shioaji as sj
    import yaml

    try:
        from hft_platform.config.loader import detect_live_credentials, load_settings
    except ImportError:

        def load_settings(cli_overrides: dict[str, Any] | None = None) -> tuple[dict[str, Any], dict[str, Any]]:
            return {}, {}

    # Get credentials
    api_key = os.environ.get("SHIOAJI_API_KEY")
    secret_key = os.environ.get("SHIOAJI_SECRET_KEY")

    if not api_key or not secret_key:
        print("Error: SHIOAJI_API_KEY and SHIOAJI_SECRET_KEY env vars required.")
        sys.exit(1)

    print("Initializing Shioaji (Simulation mode)...")
    api = sj.Shioaji(simulation=True)
    try:
        api.login(api_key=api_key, secret_key=secret_key, contracts_timeout=60000)
    except Exception as e:
        print(f"Login failed: {e}")
        sys.exit(1)

    # Get symbols
    symbols = args.symbols
    if not symbols:
        # Load from config/symbols.yaml or existing
        print("No symbols provided via args, please provide list.")
        sys.exit(1)

    print("Building contract map...")
    code_map = {}
    try:
        for c in api.Contracts.Stocks.TSE:
            code_map[c.code] = "TSE"
        for c in api.Contracts.Stocks.OTC:
            code_map[c.code] = "OTC"
    except Exception as e:
        print(f"Contract fetch warning: {e}")

    result = []
    for code in symbols:
        exch = code_map.get(code)
        if exch:
            result.append({"code": code, "exchange": exch})
        else:
            print(f"Warning: {code} not found in TSE/OTC contracts.")

    output_data = {"symbols": result}

    if args.output:
        with open(args.output, "w") as f:
            yaml.dump(output_data, f, sort_keys=False)
        print(f"Written to {args.output}")
    else:
        print(yaml.dump(output_data, sort_keys=False))


def _print_issues(errors: list[str], warnings: list[str]):
    if warnings:
        print("Warnings:")
        for msg in warnings[:20]:
            print(f"- {msg}")
        if len(warnings) > 20:
            print(f"... {len(warnings) - 20} more warnings")
    if errors:
        print("Errors:")
        for msg in errors[:20]:
            print(f"- {msg}")
        if len(errors) > 20:
            print(f"... {len(errors) - 20} more errors")


def cmd_symbols_build(args: argparse.Namespace):
    from hft_platform.config.symbols import (
        build_symbols,
        load_contract_cache,
        preview_lines,
        validate_symbols,
        write_symbols_yaml,
    )

    contract_index = None if args.no_contracts else load_contract_cache(args.contracts, args.metrics)
    result = build_symbols(args.list_path, contract_index)
    validation = validate_symbols(result.symbols, contract_index, max_subscriptions=args.max_subscriptions)

    errors = result.errors + validation.errors
    warnings = result.warnings + validation.warnings

    if args.preview:
        for line in preview_lines(result, sample=args.sample):
            print(line)

    if warnings or errors:
        _print_issues(errors, warnings)

    if errors:
        sys.exit(1)

    write_symbols_yaml(result.symbols, args.output)
    print(f"Written {len(result.symbols)} symbols to {args.output}")


def cmd_symbols_preview(args: argparse.Namespace):
    from hft_platform.config.symbols import build_symbols, load_contract_cache, preview_lines, validate_symbols

    contract_index = None if args.no_contracts else load_contract_cache(args.contracts, args.metrics)
    result = build_symbols(args.list_path, contract_index)
    validation = validate_symbols(result.symbols, contract_index, max_subscriptions=args.max_subscriptions)

    for line in preview_lines(result, sample=args.sample):
        print(line)

    errors = result.errors + validation.errors
    warnings = result.warnings + validation.warnings
    if warnings or errors:
        _print_issues(errors, warnings)

    if errors:
        sys.exit(1)


def cmd_symbols_validate(args: argparse.Namespace):
    from hft_platform.config.symbols import (
        ContractIndex,
        build_symbols,
        fetch_contracts_from_broker,
        load_contract_cache,
        load_metrics_cache,
        validate_symbols,
    )

    contract_index = None
    if args.online:
        contracts = fetch_contracts_from_broker()
        metrics = load_metrics_cache(args.metrics) if args.metrics else {}
        contract_index = ContractIndex(contracts=contracts, metrics_by_code=metrics)
    elif not args.no_contracts:
        contract_index = load_contract_cache(args.contracts, args.metrics)

    if args.symbols_path:
        import yaml

        with open(args.symbols_path, "r") as f:
            data = yaml.safe_load(f) or {}
        symbols = data.get("symbols", [])
    else:
        result = build_symbols(args.list_path, contract_index)
        symbols = result.symbols
        if result.errors:
            _print_issues(result.errors, result.warnings)
            sys.exit(1)

    validation = validate_symbols(symbols, contract_index, max_subscriptions=args.max_subscriptions)

    if validation.errors or validation.warnings:
        _print_issues(validation.errors, validation.warnings)

    if validation.errors:
        sys.exit(1)

    print("Configuration is valid.")


def cmd_symbols_sync(args: argparse.Namespace):
    from hft_platform.config.symbols import (
        ContractIndex,
        build_symbols,
        fetch_contracts_from_broker,
        load_metrics_cache,
        preview_lines,
        validate_symbols,
        write_contract_cache,
        write_symbols_yaml,
    )

    contracts = fetch_contracts_from_broker()
    write_contract_cache(contracts, args.contracts)
    metrics = load_metrics_cache(args.metrics) if args.metrics else {}
    contract_index = ContractIndex(contracts=contracts, metrics_by_code=metrics)

    result = build_symbols(args.list_path, contract_index)
    validation = validate_symbols(result.symbols, contract_index, max_subscriptions=args.max_subscriptions)

    errors = result.errors + validation.errors
    warnings = result.warnings + validation.warnings

    if args.preview:
        for line in preview_lines(result, sample=args.sample):
            print(line)

    if warnings or errors:
        _print_issues(errors, warnings)

    if errors:
        sys.exit(1)

    write_symbols_yaml(result.symbols, args.output)
    print(f"Written {len(result.symbols)} symbols to {args.output}")
    print(f"Contract cache saved to {args.contracts}")


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(prog="hft", description="HFT Platform CLI")
    sub = parser.add_subparsers(dest="command")

    # ... (Previous commands)

    config_cmd = sub.add_parser("config", help="Configuration utilities")
    config_sub = config_cmd.add_subparsers(dest="config_cmd")

    resolve = config_sub.add_parser("resolve", help="Resolve exchanges for symbols")
    resolve.add_argument("symbols", nargs="+", help="List of stock codes")
    resolve.add_argument("--output", help="Output YAML file path")
    resolve.set_defaults(func=cmd_resolve_symbols)

    build = config_sub.add_parser("build", help="Build symbols.yaml from symbols.list")
    build.add_argument("--list", dest="list_path", default="config/symbols.list", help="Input symbols list")
    build.add_argument("--output", default="config/symbols.yaml", help="Output symbols YAML")
    build.add_argument("--contracts", default="config/contracts.json", help="Contract cache path")
    build.add_argument("--metrics", default=None, help="Metrics cache path (optional)")
    build.add_argument("--no-contracts", action="store_true", help="Skip contract cache lookup")
    build.add_argument("--max-subscriptions", type=int, default=200, help="Subscription limit")
    build.add_argument("--preview", action="store_true", help="Show preview summary")
    build.add_argument("--sample", type=int, default=10, help="Preview sample size")
    build.set_defaults(func=cmd_symbols_build)

    preview = config_sub.add_parser("preview", help="Preview expanded symbols list")
    preview.add_argument("--list", dest="list_path", default="config/symbols.list", help="Input symbols list")
    preview.add_argument("--contracts", default="config/contracts.json", help="Contract cache path")
    preview.add_argument("--metrics", default=None, help="Metrics cache path (optional)")
    preview.add_argument("--no-contracts", action="store_true", help="Skip contract cache lookup")
    preview.add_argument("--max-subscriptions", type=int, default=200, help="Subscription limit")
    preview.add_argument("--sample", type=int, default=10, help="Preview sample size")
    preview.set_defaults(func=cmd_symbols_preview)

    validate = config_sub.add_parser("validate", help="Validate symbols configuration")
    validate.add_argument("--list", dest="list_path", default="config/symbols.list", help="Input symbols list")
    validate.add_argument("--symbols", dest="symbols_path", help="Validate an existing symbols.yaml")
    validate.add_argument("--contracts", default="config/contracts.json", help="Contract cache path")
    validate.add_argument("--metrics", default=None, help="Metrics cache path (optional)")
    validate.add_argument("--no-contracts", action="store_true", help="Skip contract cache lookup")
    validate.add_argument("--online", action="store_true", help="Validate against broker contracts")
    validate.add_argument("--max-subscriptions", type=int, default=200, help="Subscription limit")
    validate.set_defaults(func=cmd_symbols_validate)

    sync = config_sub.add_parser("sync", help="Sync broker contracts and build symbols.yaml")
    sync.add_argument("--list", dest="list_path", default="config/symbols.list", help="Input symbols list")
    sync.add_argument("--output", default="config/symbols.yaml", help="Output symbols YAML")
    sync.add_argument("--contracts", default="config/contracts.json", help="Contract cache path")
    sync.add_argument("--metrics", default=None, help="Metrics cache path (optional)")
    sync.add_argument("--max-subscriptions", type=int, default=200, help="Subscription limit")
    sync.add_argument("--preview", action="store_true", help="Show preview summary")
    sync.add_argument("--sample", type=int, default=10, help="Preview sample size")
    sync.set_defaults(func=cmd_symbols_sync)

    run = sub.add_parser("run", help="Run pipeline (sim|live|replay)")
    run.add_argument("mode", nargs="?", choices=["sim", "live", "replay"])
    run.add_argument("--mode", dest="mode_flag", choices=["sim", "live", "replay"])
    run.add_argument("--strategy", help="Strategy id to run")
    run.add_argument("--strategy-module", help="Override strategy module")
    run.add_argument("--strategy-class", help="Override strategy class")
    run.add_argument("--symbols", nargs="+", help="Symbols to load")
    run.set_defaults(func=cmd_run)

    init = sub.add_parser("init", help="Generate settings and strategy skeleton")
    init.add_argument("--strategy-id", help="Strategy id/name")
    init.add_argument("--symbol", help="Primary symbol")
    init.set_defaults(func=cmd_init)

    check = sub.add_parser("check", help="Validate settings")
    check.add_argument("--export", choices=["yaml", "json"], help="Export effective settings")
    check.set_defaults(func=cmd_check)

    wizard = sub.add_parser("wizard", help="Interactive configuration setup")
    wizard.set_defaults(func=cmd_wizard)

    feed = sub.add_parser("feed", help="Feed utilities")
    feed_sub = feed.add_subparsers(dest="feed_cmd")
    feed_status = feed_sub.add_parser("status", help="Check feed metrics")
    feed_status.add_argument("--port", type=int, default=9090)
    feed_status.set_defaults(func=cmd_feed_status)

    diag = sub.add_parser("diag", help="Quick diagnostics")
    diag.set_defaults(func=cmd_diag)

    strat = sub.add_parser("strat", help="Strategy helpers")
    strat_sub = strat.add_subparsers(dest="strat_cmd")
    strat_test = strat_sub.add_parser("test", help="Run a synthetic smoke test for strategy")
    strat_test.add_argument("--strategy-id", help="Strategy id")
    strat_test.add_argument("--module", help="Strategy module path")
    strat_test.add_argument("--cls", help="Strategy class name")
    strat_test.add_argument("--symbol", help="Symbol to test")
    strat_test.set_defaults(func=cmd_strat_test)

    backtest = sub.add_parser("backtest", help="Backtest utilities (convert/run)")
    back_sub = backtest.add_subparsers(dest="backtest_cmd")

    back_convert = back_sub.add_parser("convert", help="Convert JSONL feed to hftbacktest npz")
    back_convert.add_argument("--input", required=True, help="Input JSONL (our normalized events)")
    back_convert.add_argument("--output", required=True, help="Output npz path")
    back_convert.add_argument("--scale", type=int, default=10000, help="Price scale (default 10000)")
    back_convert.set_defaults(func=cmd_backtest)

    back_run = back_sub.add_parser("run", help="Run backtest using hftbacktest")
    back_run.add_argument("--data", nargs="+", required=True, help="NPZ paths containing hftbacktest event data")
    back_run.add_argument("--tick-size", type=float, default=0.01, help="Tick size")
    back_run.add_argument("--lot-size", type=float, default=1.0, help="Lot size")
    back_run.add_argument("--tick-sizes", nargs="+", type=float, help="Tick sizes per asset (align with data)")
    back_run.add_argument("--lot-sizes", nargs="+", type=float, help="Lot sizes per asset (align with data)")
    back_run.add_argument("--symbols", nargs="+", help="Symbols per asset (align with data)")
    back_run.add_argument("--record-out", help="Path to save recorder output npz")
    back_run.add_argument("--strategy-module", help="Strategy module path for adapter")
    back_run.add_argument("--strategy-class", help="Strategy class for adapter")
    back_run.add_argument("--strategy-id", help="Strategy id", default="demo")
    back_run.add_argument("--symbol", help="Symbol", default="2330")
    back_run.add_argument("--price-scale", type=int, default=10000, help="Price scale used by strategy ints")
    back_run.add_argument("--timeout", type=int, default=0, help="wait_next_feed timeout (0 = no timeout)")
    back_run.add_argument("--latency-entry", type=float, help="Order entry latency for backtest")
    back_run.add_argument("--latency-resp", type=float, help="Order response latency for backtest")
    back_run.add_argument("--fee-maker", type=float, help="Maker fee (per value, negative for rebate)")
    back_run.add_argument("--fee-taker", type=float, help="Taker fee (per value, negative for rebate)")
    back_run.add_argument(
        "--no-partial-fill", action="store_true", help="Disable partial fill (use no_partial_fill_exchange)"
    )
    back_run.add_argument("--report", action="store_true", help="Generate HTML Tearsheet")
    back_run.set_defaults(func=cmd_backtest)

    return parser


def main(argv=None):
    configure_logging()
    parser = build_parser()
    args = parser.parse_args(argv)
    if not hasattr(args, "func"):
        parser.print_help()
        return 1
    args.func(args)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
