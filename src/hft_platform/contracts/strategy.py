from dataclasses import dataclass
from enum import IntEnum
from typing import Optional


class Side(IntEnum):
    BUY = 0
    SELL = 1


class TIF(IntEnum):
    LIMIT = 0
    IOC = 1
    FOK = 2
    ROD = 3


class IntentType(IntEnum):
    NEW = 0
    AMEND = 1
    CANCEL = 2


class StormGuardState(IntEnum):
    NORMAL = 0
    WARM = 1
    STORM = 2
    HALT = 3


@dataclass(slots=True)
class OrderIntent:
    """
    Generated by Strategy, validated by Risk, sent to Adapter.
    Optimized for slots/memory.
    """

    intent_id: int
    strategy_id: str
    symbol: str
    intent_type: IntentType
    side: Side
    price: int  # Fixed point (x10000)
    qty: int
    tif: TIF = TIF.LIMIT
    target_order_id: Optional[str] = None  # For AMEND/CANCEL
    timestamp_ns: int = 0
    source_ts_ns: int = 0

    # Metadata for risk/adapter
    reason: str = ""
    trace_id: str = ""  # OpenTelemetry Trace ID for distributed tracing support

    # CE2-01: Gateway idempotency and TTL fields (default-valued, backward-compat)
    idempotency_key: str = ""  # Caller-supplied dedup key; empty = no dedup
    ttl_ns: int = 0  # Expiry in nanoseconds from enqueue; 0 = no expiry


@dataclass(slots=True)
class RiskDecision:
    """
    Output of Risk Engine.
    """

    approved: bool
    intent: OrderIntent
    reason_code: str = "OK"
    modified: bool = False  # If risk adjusted size/price


@dataclass(slots=True)
class OrderCommand:
    """
    Command for OrderAdapter (coalesced).
    """

    cmd_id: int
    intent: OrderIntent
    deadline_ns: int
    storm_guard_state: StormGuardState
    created_ns: int = 0
